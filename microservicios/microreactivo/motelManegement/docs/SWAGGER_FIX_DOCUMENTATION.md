# Swagger /v3/api-docs Fetch Error - Solution Documentation

## Problem Analysis

### What was happening exactly?
When trying to access the Swagger UI for the motelManagement service at `http://localhost:8084/swagger-ui.html`, the interface would fail to load properly with the error:
```
Failed to fetch /v3/api-docs
```

This error meant that while the Swagger UI page was accessible, it couldn't retrieve the OpenAPI specification document from the `/v3/api-docs` endpoint.

### Why did the bug occur?

The issue had multiple root causes:

1. **Incomplete SpringDoc OpenAPI Configuration**: The `application.yml` was missing key configuration properties that explicitly enable the API docs endpoint and configure the Swagger UI properly.

2. **Missing Schema File**: Spring Boot's SQL initialization system looks for files named `schema.sql` or `schema-{platform}.sql` by convention. The motelManagement service had a file named `Postgres-init-motel.sql` which wasn't being automatically discovered and executed.

3. **Test Configuration Issues**: The test suite was trying to connect to PostgreSQL instead of using an in-memory H2 database for testing, which would cause the application context to fail to load during tests.

## Solution Implemented

### 1. Enhanced SpringDoc OpenAPI Configuration

**File**: `src/main/resources/application.yml`

Added explicit configuration properties:

```yaml
# SpringDoc OpenAPI Configuration
springdoc:
  api-docs:
    path: /v3/api-docs
    enabled: true                           # Explicitly enable API docs
  swagger-ui:
    path: /swagger-ui.html
    enabled: true                           # Explicitly enable Swagger UI
    tags-sorter: alpha                      # Sort tags alphabetically
    operations-sorter: alpha                # Sort operations alphabetically
  show-actuator: true                      # Show actuator endpoints in docs
  default-produces-media-type: application/json
  default-consumes-media-type: application/json
```

**Key Changes**:
- `enabled: true` for both `api-docs` and `swagger-ui` ensures the endpoints are explicitly activated
- `tags-sorter` and `operations-sorter` provide better organization in the UI
- `show-actuator: true` includes actuator endpoints in the documentation
- Default media types ensure proper content negotiation

### 2. Created Standard Schema File

**File**: `src/main/resources/schema.sql`

Created a copy of the existing `Postgres-init-motel.sql` file with the standard Spring Boot naming convention. Spring Boot automatically discovers and executes `schema.sql` during application startup when `spring.sql.init.mode` is set to `always`.

### 3. Fixed Test Configuration

**Changes Made**:

a. **Added Test Dependencies** (`pom.xml`):
```xml
<!-- H2 Database for testing -->
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>test</scope>
</dependency>

<dependency>
    <groupId>io.r2dbc</groupId>
    <artifactId>r2dbc-h2</artifactId>
    <scope>test</scope>
</dependency>
```

b. **Created H2-Compatible Schema** (`src/test/resources/schema-h2.sql`):
- Replaced PostgreSQL's `BIGSERIAL` with H2's `BIGINT GENERATED BY DEFAULT AS IDENTITY`
- Removed PostgreSQL-specific syntax like `ON CONFLICT`
- Kept all table structures and relationships intact

c. **Updated Test Class**:
```java
@SpringBootTest
@ActiveProfiles("test")  // Added this annotation
class UserManagementApplicationTests {
    @Test
    void contextLoads() {
    }
}
```

d. **Updated Test Configuration** (`src/test/resources/application-test.yml`):
```yaml
spring:
  r2dbc:
    url: r2dbc:h2:mem:///motel_management_test;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    username: sa
    password: ""
  sql:
    init:
      mode: always
      platform: h2
      schema-locations: classpath:schema-h2.sql  # Explicitly load H2 schema
```

## How to Verify the Fix

1. **Start the application**:
   ```bash
   ./mvnw spring-boot:run
   ```

2. **Access Swagger UI**:
   Open your browser and navigate to: `http://localhost:8084/swagger-ui.html`

3. **Verify API Docs**:
   You can also directly access the OpenAPI specification at: `http://localhost:8084/v3/api-docs`

4. **Run tests**:
   ```bash
   ./mvnw test
   ```
   All tests should pass successfully.

## How to Prevent Similar Bugs in the Future

### 1. Use Configuration Templates
When creating new Spring Boot reactive microservices with SpringDoc, always use a standard configuration template:

```yaml
springdoc:
  api-docs:
    path: /v3/api-docs
    enabled: true
  swagger-ui:
    path: /swagger-ui.html
    enabled: true
    tags-sorter: alpha
    operations-sorter: alpha
  show-actuator: true
  default-produces-media-type: application/json
  default-consumes-media-type: application/json
```

### 2. Follow Spring Boot Naming Conventions
- Use `schema.sql` or `schema-{platform}.sql` for database schemas
- Use `data.sql` or `data-{platform}.sql` for seed data
- Spring Boot will automatically discover and execute these files

### 3. Always Configure Test Environment Properly
- Use in-memory databases (H2) for testing
- Create separate schema files for test environments when needed
- Use `@ActiveProfiles("test")` in test classes
- Explicitly configure test resources in `application-test.yml`

### 4. Test the Full Application Context
- Always include a basic `contextLoads()` test
- This ensures the application can start successfully
- Catches configuration issues early

### 5. Check SpringDoc Logs
Enable debug logging for SpringDoc to troubleshoot issues:
```yaml
logging:
  level:
    org.springdoc: DEBUG
```

### 6. Verify Dependencies
Ensure you're using the correct SpringDoc dependency for your reactive stack:
- For WebFlux: `springdoc-openapi-starter-webflux-ui`
- For WebMVC: `springdoc-openapi-starter-webmvc-ui`

### 7. Document API Endpoints
Always use Swagger/OpenAPI annotations on controllers:
- `@Tag` for controller-level documentation
- `@Operation` for method-level documentation
- `@ApiResponses` for response documentation
- `@Parameter` for parameter documentation

## Best Practices

1. **Version Control for API Docs**: Keep your OpenAPI configuration in version control and review changes carefully.

2. **Consistent Configuration**: Use the same SpringDoc configuration across all microservices in your architecture for consistency.

3. **Automated Testing**: Include tests that verify Swagger UI is accessible and the API docs are generated correctly.

4. **Documentation First**: Write API documentation as you develop features, not as an afterthought.

5. **Schema Management**: Consider using database migration tools like Flyway or Liquibase for production environments instead of Spring Boot's built-in SQL initialization.

## Additional Resources

- [SpringDoc OpenAPI Documentation](https://springdoc.org/)
- [Spring Boot SQL Initialization](https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.data-initialization.using-basic-sql-scripts)
- [Spring WebFlux Documentation](https://docs.spring.io/spring-framework/reference/web/webflux.html)
- [OpenAPI Specification](https://swagger.io/specification/)

## Summary

The Swagger fetch error was caused by incomplete configuration rather than a code bug. By explicitly enabling the SpringDoc endpoints, following Spring Boot naming conventions for SQL scripts, and properly configuring the test environment, we resolved all issues. The application now properly serves its OpenAPI specification and displays the Swagger UI interface correctly.
